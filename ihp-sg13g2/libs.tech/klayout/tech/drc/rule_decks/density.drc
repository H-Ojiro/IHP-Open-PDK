# frozen_string_literal: true

#=========================================================================================
# Copyright 2025 IHP PDK Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#=========================================================================================

#====================================================================================================================
#--------------------------------------------- IHP-SG13G2 DRC RULE DECK ---------------------------------------------
#====================================================================================================================
require 'time'
require 'logger'
require 'etc'
require 'json'
require 'pathname'

exec_start_time = Time.now

logger = Logger.new($stdout)

logger.formatter = proc do |_severity, datetime, _progname, msg|
  "#{datetime}: Memory Usage (" + `pmap #{Process.pid} | tail -1`[10, 40].strip + ") : #{msg}
"
end

#================================================
#----------------- FILE SETUP -------------------
#================================================

logger.info("Starting running IHP-SG13G2 Klayout DRC Density runset on #{$input}")
logger.info("Ruby Version for klayout: #{RUBY_VERSION}")

if $input
  if $topcell
    source($input, $topcell)
  else
    source($input)
  end
end

logger.info('Loading database to memory is complete.')

if $report
  logger.info("IHP-SG13G2 Klayout DRC Density runset output at: #{$report}")
  report('Density DRC Run Report at', $report)
else
  layout_dir = Pathname.new(RBA::CellView.active.filename).parent.realpath
  report_path = layout_dir.join('sg13g2_drc_density.lyrdb').to_s
  logger.info("IHP-SG13G2 Klayout DRC Density runset output at default location: #{report_path}")
  report('Density DRC Run Report at', report_path)
end

#================================================
#------------------ SWITCHES --------------------
#================================================

logger.info('Evaluate switches.')

def bool_check?(obj)
  obj.to_s.downcase == 'true'
end

# threads
if $thr
  threads($thr)
else
  thr ||= Etc.nprocessors
  threads(thr)
end

logger.info("Klayout will use #{$thr} thread(s)")

# === TILING MODE ===
case $run_mode
## Tiling mode is for testing purpose only [Not used in run_drc.py]
when 'tiling'
  tiles(500.um)
  tile_borders(10.um)
  logger.info('Tiling  mode is enabled.')

when 'deep'
  #=== HIER MODE ===
  deep
  logger.info('deep  mode is enabled for density table')
else
  #=== FLAT MODE ===
  flat
  logger.info('flat  mode is enabled for density table')
end

# MinRuleSet
MaxRuleSet = bool_check?($MaxRuleSet)
logger.info("Maximum rule set enabled:  #{MaxRuleSet}")

#================================================
#------------- LAYERS DEFINITIONS ---------------
#================================================

# %include layers_def.drc

#================================================
# -------------------- UTILS --------------------
#================================================

# Method to get DRC values from JSON files
def get_drc_values(logger)
  tech_rules = {}
  if $drc_json && $drc_json != $drc_json_default
    begin
      tech_drc_content = File.read($drc_json)
      tech_drc_data = JSON.parse(tech_drc_content)
      tech_rules = tech_drc_data['drc_rules'] || {}
      logger.info("Loaded TECH DRC rules values from #{$drc_json}")
    rescue StandardError => e
      logger.error("Error reading TECH DRC rules from #{$drc_json}: #{e.message}")
    end
  end

  begin
    default_drc_content = File.read($drc_json_default)
    default_drc_data = JSON.parse(default_drc_content)
    default_rules = default_drc_data['drc_rules'] || {}
    logger.info("Loaded default DRC rules values from #{$drc_json_default}")
  rescue StandardError => e
    logger.error("Error reading default DRC rules from #{$drc_json_default}: #{e.message}")
    return {}
  end

  merged_rules = tech_rules.merge(default_rules)

  # Report any fallback rules used
  missing_keys = default_rules.keys - tech_rules.keys
  unless missing_keys.empty?
    logger.warn('The following rules values were missing in tech json and default values were used:')
    missing_keys.each { |rule| logger.warn("  - #{rule}") }
  end

  merged_rules
end

# Extract DRC rules values from the JSON file
drc_rules = get_drc_values(logger)

#================================================
#-------------- COMMON DERIVATIONS --------------
#================================================

# === LAYOUT EXTENT ===
CHIP = extent.sized(0.0)
logger.info("Total area of the design is #{CHIP.area} um^2.")
tiles_boundary = tile_boundary(CHIP)
chip_bbox = CHIP.bbox

# Density derivations
activ = activ_drw.join(activ_filler).join(activ_mask)
poly = gatpoly_drw.join(gatpoly_filler)
metal1 = metal1_drw.join(metal1_filler).not(metal1_slit)
metal2 = metal2_drw.join(metal2_filler).not(metal2_slit)
metal3 = metal3_drw.join(metal3_filler).not(metal3_slit)
metal4 = metal4_drw.join(metal4_filler).not(metal4_slit)
metal5 = metal5_drw.join(metal5_filler).not(metal5_slit)
topmetal1 = topmetal1_drw.join(topmetal1_filler).not(topmetal1_slit)
topmetal2 = topmetal2_drw.join(topmetal2_filler).not(topmetal2_slit)

#===================================================================================
# --------------------------------- DENSITY RUNSET ---------------------------------
#===================================================================================

logger.info('Starting IHP-SG13G2 DENSITY DRC rules.')

#===================================================
# --------------------- ActFil ---------------------
#===================================================

# Rule AFil.g: Min. global Activ density [%]= 35.0.
logger.info('Executing rule AFil.g')
afil_g_val = drc_rules['AFil_g'].to_f
if (activ.area / CHIP.area) < afil_g_val
  CHIP.output('AFil.g',
              "5.6. AFil.g: Min. global Activ density [%]: #{afil_g_val * 100}.")
end

# Rule AFil.g1: Max. global Activ density [%]= 55.0.
logger.info('Executing rule AFil.g1')
afil_g1_val = drc_rules['AFil_g1'].to_f
if (activ.area / CHIP.area) > afil_g1_val
  CHIP.output('AFil.g1',
              "5.6. AFil.g1: Max. global Activ density [%]: #{afil_g1_val * 100}.")
end

# ActFil window Variables
afil_g_w = drc_rules['AFil_g_w'].to_f
act_size = afil_g_w.um
act_step = 0.5 * act_size
act_org_x = chip_bbox.left + act_step / 2
act_org_y = chip_bbox.bottom + act_step / 2
act_tile_size = tile_size(act_size)
act_tile_step = tile_step(act_step)
act_tile_origin = tile_origin(act_org_x, act_org_y)

# Rule AFil.g2: Min. Activ coverage ratio for any 800 x 800 µm2 chip area [%]= 25.00.
logger.info('Executing rule AFil.g2')
afil_g2_val = drc_rules['AFil_g2'].to_f
afilg2_min = activ.with_density(0.0..afil_g2_val,
                                act_tile_size,
                                act_tile_step,
                                tiles_boundary,
                                act_tile_origin,
                                padding_ignore)
afilg2_min.output('AFil.g2',
                  "5.6. AFil.g2: Min. Activ coverage ratio for any #{afil_g_w} x #{afil_g_w} µm2 chip area [%]: #{afil_g2_val * 100}.")
afilg2_min.forget

# Rule AFil.g3: Max. Activ coverage ratio for any 800 x 800 µm2 chip area [%]= 65.00.
logger.info('Executing rule AFil.g3')
afil_g3_val = drc_rules['AFil_g3'].to_f
afilg3_max = activ.with_density(afil_g3_val..1.0,
                                act_tile_size,
                                act_tile_step,
                                tiles_boundary,
                                act_tile_origin,
                                padding_ignore)

afilg3_max.output('AFil.g3',
                  "5.6. AFil.g3: Max. Activ coverage ratio for any any #{afil_g_w} x #{afil_g_w} µm2 chip area [%]: #{afil_g3_val * 100}.")
afilg3_max.forget

#==================================================
# -------------------- GatPoly --------------------
#==================================================

# Rule GFil.g: Min. global GatPoly density [%]= 15.0.
logger.info('Executing rule GFil.g')
gfil_g_val = drc_rules['GFil_g'].to_f
if (poly.area / CHIP.area) < gfil_g_val
  CHIP.output('GFil.g',
              "5.9. GFil.g: Min. global GatPoly density [%]: #{gfil_g_val * 100}.")
end

#=================================================
# -------------------- Metal1 --------------------
#=================================================

m1_j_val = drc_rules['M1_j'].to_f
m1_k_val = drc_rules['M1_k'].to_f

# Rule Mn.j: Min. global Metaln density [%]= 35.0.
logger.info('Executing rule M1.j')
if (metal1.area / CHIP.area) < m1_j_val
  CHIP.output('M1.j',
              "5.9. M1.j: Min. global Metal1 density [%]: #{m1_j_val * 100}.")
end

# Rule Mn.k: Max. global Metaln density [%]= 60.0.
logger.info('Executing rule M1.k')
if (metal1.area / CHIP.area) > m1_k_val
  CHIP.output('M1.k',
              "5.9. M1.k: Max. global Metal1 density [%]: #{m1_k_val * 100}.")
end

#=================================================
# -------------------- Metaln --------------------
#=================================================

mets_lay = [metal2, metal3, metal4, metal5]
metal_start_index = 2
mn_j_val = drc_rules['Mn_j'].to_f
mn_k_val = drc_rules['Mn_k'].to_f

mets_lay.each_with_index do |met_lay, index|
  met_no = index + metal_start_index

  # Rule Mn.j: Min. global Metaln density [%]= 35.0.
  logger.info("Executing rule M#{met_no}.j")
  if (met_lay.area / CHIP.area) < mn_j_val
    CHIP.output("M#{met_no}.j",
                "5.9. M#{met_no}.j: Min. global Metal#{met_no} density [%]: #{mn_j_val * 100}.")
  end

  # Rule Mn.k: Max. global Metaln density [%]= 60.0.
  logger.info("Executing rule M#{met_no}.k")
  if (met_lay.area / CHIP.area) > mn_k_val
    CHIP.output("M#{met_no}.k",
                "5.9. M#{met_no}.k: Max. global Metal#{met_no} density [%]: #{mn_k_val * 100}.")
  end
end

#=================================================
# ------------------- MetalFil -------------------
#=================================================

# Metals Variables
mfil_h_w = drc_rules['MFil_h_w'].to_f
met_size = mfil_h_w.um
met_step = 0.5 * met_size
met_org_x = chip_bbox.left + met_step / 2
met_org_y = chip_bbox.bottom + met_step / 2
met_tile_size = tile_size(met_size)
met_tile_step = tile_step(met_step)
met_tile_origin = tile_origin(met_org_x, met_org_y)

mets_lay = [metal1, metal2, metal3, metal4, metal5]
metal_start_index = 1
mfil_h_val = drc_rules['MFil_h'].to_f
mfil_k_val = drc_rules['MFil_k'].to_f

mets_lay.each_with_index do |met_lay, index|
  metalfiller_no = index + metal_start_index

  # Rule MFil.h: Min. Metal(n) and Metal(n):filler coverage ratio for any 800 x 800 µm2 chip area [%]= 25.0.
  logger.info("Executing rule M#{metalfiller_no}Fil.h")
  mfilh_min = met_lay.with_density(0.0..mfil_h_val,
                                   met_tile_size,
                                   met_tile_step,
                                   tiles_boundary,
                                   met_tile_origin,
                                   padding_ignore)
  mfilh_min.output("M#{metalfiller_no}Fil.h",
                   "5.6. M#{metalfiller_no}Fil.h: Min. Metal#{metalfiller_no} and Metal#{metalfiller_no}:filler \
                   coverage ratio for any #{mfil_h_w} x #{mfil_h_w} µm2 chip area [%]: #{mfil_h_val * 100}")
  mfilh_min.forget

  # Rule MFil.k: Max. Metal(n) and Metal(n):filler coverage ratio for any 800 x 800 µm2 chip area [%]= 75.0.
  logger.info("Executing rule M#{metalfiller_no}Fil.k")
  mfilk_max = met_lay.with_density(mfil_k_val..1.0,
                                   met_tile_size,
                                   met_tile_step,
                                   tiles_boundary,
                                   met_tile_origin,
                                   padding_ignore)
  mfilk_max.output("M#{metalfiller_no}Fil.k",
                   "5.6. M#{metalfiller_no}Fil.k: Max. Activ coverage ratio for any #{mfil_h_w} x #{mfil_h_w} µm2 chip area [%]: #{mfil_k_val * 100}.")
  mfilk_max.forget
end

#================================================
# ------------------ TopMetal1 ------------------
#================================================

# Rule TM1.c: Min. global TopMetal1 density [%]= 25.0.
logger.info('Executing rule TM1.c')
tm1_c_val = drc_rules['TM1_c'].to_f
if (topmetal1.area / CHIP.area) < tm1_c_val
  CHIP.output('TM1.c', "5.22. TM1.c: Min. global TopMetal1 density [%]: #{tm1_c_val * 100}.")
end

# Rule TM1.d: Max. global TopMetal1 density [%]= 70.0.
logger.info('Executing rule TM1.d')
tm1_d_val = drc_rules['TM1_d'].to_f
if (topmetal1.area / CHIP.area) > tm1_d_val
  CHIP.output('TM1.d', "5.22. TM1.d: Max. global TopMetal1 density [%]: #{tm1_d_val * 100}")
end

#================================================
# ------------------ TopMetal2 ------------------
#================================================

# Rule TM2.c: Min. global TopMetal2 density [%]= 25.0.
logger.info('Executing rule TM2.c')
tm2_c_val = drc_rules['TM2_c'].to_f
if (topmetal2.area / CHIP.area) < tm2_c_val
  CHIP.output('TM2.c', "5.22. TM2.c: Min. global TopMetal2 density [%]: #{tm2_c_val * 100}.")
end

# Rule TM2.d: Max. global TopMetal2 density [%]= 70.0.
logger.info('Executing rule TM2.d')
tm2_d_val = drc_rules['TM2_d'].to_f
if (topmetal2.area / CHIP.area) > tm2_d_val
  CHIP.output('TM2.d', "5.22. TM2.d: Max. global TopMetal2 density [%]: #{tm2_d_val * 100}.")
end

#================================================
# --------------------- LBE ---------------------
#================================================

# Rule LBE.i: Max. global LBE density [%]= 20.00.
logger.info('Executing rule LBE.i')
lbe_i_val = drc_rules['LBE_i'].to_f
if (lbe_drw.area / CHIP.area) > lbe_i_val
  CHIP.output('LBE.i',
              "5.22. LBE.i: Max. global LBE density [%]: #{lbe_i_val * 100}.")
end

#================================================
# ---------------- Metal Slits ------------------
#================================================

# ===================================
exec_end_time = Time.now
run_time = exec_end_time - exec_start_time
logger.info(format('DRC Total Run time %f seconds', run_time))

#===================================
#--------------- END ---------------
#===================================
